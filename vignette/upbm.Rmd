---
title: "upbm: Analysis of Protein Binding Microarrays in R"
author: Patrick K. Kimes
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('upbm')`"
output:
  BiocStyle::html_document:
    highlight: pygments
    toc: true
    fig_width: 12
    fig_height: 4
vignette: >
  %\VignetteIndexEntry{Analysis with upbm}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r echo=FALSE, include=FALSE}
knitr::opts_chunk$set(tidy = FALSE, cache = TRUE, dev = "png",
                      message = FALSE, error = FALSE, warning = TRUE)
```

**THIS PACKAGE IS STILL UNDER ACTIVE DEVELOPMENT**

# Introduction

This package provides tools for reading, plotting, and analyzing protein binding microarray (PBM) data in *R*. Currently, input data must be available as GenePix Results (GPR) files. A more stable and separate set of tools developed by Berger and Bulyk (Nature Protocols, 2009) for the analysis of PBMs is available for download at the [_Universal PBM Analysis Suite_ site](the_brain.bwh.harvard.edu/PBMAnalysisSuite/indexSep2017.html).

Several functions for loading and preprocessing microarray data are available in *R* through the widely used [*affy*](https://www.bioconductor.org/packages/release/bioc/html/affy.html) and [*limma*](http://bioconductor.org/packages/release/bioc/html/limma.html) packages. Additionally, the *limma* package also includes several functions for gene-level quantification and testing of differential expression with expression arrays. Rather than reinventing the wheel, this package (*upbm*) includes several easy-to-use wrappers to the pre-processing functions implemented in both *affy* and *limma* (prefixed `rma*` and `limma*`, respectively). Due to the specialized nature of PBMs, the *upbm* package includes specialized procedures for k-mer-level quantification not implemented in either of the aforementioned packages. 

# Installation

To install the latest version of this package from GitHub, use the following command from the `devtools` package:

```{r, eval = FALSE}
devtools::install_github("pkimes/upbm")
```

If the package is already installed, there is no need to re-install the package except to check for updates.
After installing, the package still needs to be loaded to make the functions available in R.

```{r}
suppressPackageStartupMessages(library("upbm"))
```

# Quickstart

Suppose we have a folder, `gpr_dir`, containing GPR files for a single experiment. We first determine the set of samples in that folder with `buildPBMTable`, and then read in the samples using `buildPBMExperiment`.

```{r, eval = FALSE}
pbmtab <- buildPBMTable(gpr_dir)
pbmdat <- buildPBMExperiment(samples, probes = pbm_8x60k_v1)
```

For this vignette, we just use a toy data set included with this package.

```{r}
data(pbmtab)
data(pbmdat)
```

The data is now available for plotting and analysis. Here, we show an example of computing the spatial bias in a subset of samples, and plotting the bias across the grid of probe coordinates.

```{r}
pbm_adjusted <- spatiallyAdjust(pbmdat[, 1:3])
```

```{r, fig.width = 12, fig.height = 4}
pbmPlotChip(pbm_adjusted, assay_name = "spatialbias", log_scale = FALSE)
```

More details on the available plotting and analysis functions are provided in the sections below.

# Overview

## Reading GPR Data

We start by identifying the set of sample GPRs in the directory, `gpr_dir` using the `buildPBMTable` function.

```{r, eval = FALSE}
pbmtab <- buildPBMTable(gpr_dir)
```

Going back to the example data set, the table includes various sample meta data pulled from the file names according to an assumed convention described in the `buildPBMTable` function details.

```{r}
pbmtab
```

By default, only raw `"Alexa"` GPR scans are captured. However, there may also be Cy3 and Masliner GPR files of interest in the same directory. To capture these samples as well, we can change the `gpr_type=` parameter to any of `"Masliner"`, `"Cy3"`, or `"all"`.

```{r, eval = FALSE}
samples_all <- buildPBMTable(gpr_dir, gpr_type = "all")
```

Given the table of samples, we next load the GPR data into R using the `buildPBMExperiment` function. The function reads in GPR data for the files listed in the `gpr` column of the sample table. The `gpr` column is the only required column for input into the `buildPBMExperiment` function. While optional, if possible, the probe design should also be specified when loading the GPR data for easier downstream analysis. For convenience, the default "8x60k" probe design is included in this package as `pbm_8x60_v1`. (The `probes =` argument is described in further detail below.)

```{r, eval = FALSE}
pbmdata <- buildPBMExperiment(samples_all, probes = pbm_8x60k_v1)
```

The sample data is stored as a [_SummarizedExperiment_](https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html), a common structure for storing genomic data in [Bioconductor](http://bioconductor.org/).

```{r}
pbmdata
```

A _SummarizedExperiment_ is made up of three parts: **1.** assays (primary data), **2.** column data, and **3.** row data.  

Naturally, the probe-level intensities from the GPRs are available in the `"fore"` (foreground) **assay** as a DataFrame with rows and columns corresponding to probes and samples. A second assay, `"back"` (background) is also read in from the GPRs with the background intensities for each probe and sample.

```{r}
assay(pbmdata, "fore")[1:5, 1:5]
assay(pbmdata, "back")[1:5, 1:5]
```

The **column data** contains information about the columns (samples).

```{r}
colData(pbmdat)[1:5, ]
```

Similarly, the **row data** contains information about the rows (probes). Recall that when we loaded the GPR data, we also specified the probe design used in this experiment, `pbm_8x60k_v1`. This data is now stored as the row data. 

```{r}
rowData(pbmdat)[1:5, ]
```

The probe information in `pbm_8x60_v1` was matched with the GPR data according to `Row` and `Column` coordinates.

```{r}
head(pbm_8x60k_v1)
```

## Plotting GPR Data

Now that we have the data, we can use plots to visually explore the distributions of probe intensities across samples. Currently, the following functions are available for plotting GPR data: `pbmPlotDensity()`, `pbmPlotChip()`, `pbmPlotScatter()`, and `pbmPlotComparison()`. Each function returns a `ggplot2` object that can be customized to generate more specialized plots. By default, each function plots each sample separately ("facets") according to the `condition` column of the `colData`.

```{r}
colData(pbmdat)$condition
```

If `condition` is not unique to each sample, as is the case here, we can set `.facet = FALSE` in the function, and explicitly facet the returned plot. Faceting can be performed using any of the columns in the `colData` of the SummarizedExperiment.

```{r}
colData(pbmdat)
```

In this example, laser power (`lp`) and `condition` uniquely identify each sample, and can be used for faceting the samples.  

First, we use `lp` and `condition` to facet a plot of the distribution of probe intensities for each sample. 

```{r, fig.width = 10, fig.height = 6}
pbmPlotDensity(pbmdat, .facet = FALSE) +
    facet_grid(lp ~ condition)
```

Similarly, we can plot probe intensities for each sample across the coordinates of the array. 

```{r, fig.width = 10, fig.height = 6}
pbmPlotDensity(pbmdat, .facet = FALSE) +
    facet_grid(lp ~ condition)
```

Since these experiments typically include a reference sample, another useful view of the data is to plot probe intensities across conditions against a reference sample. This may be useful to, for example, compare across conditions for a fixed laser power (`lp`) or across laser powers for a single condition (`condition`). Since the ultimate goal is to compare across samples, we plot the former. To do this, we simply subset the samples (columns) according to the `colData`, and call the plotting function. 

```{r, fig.width = 10, fig.height = 6}
pbmPlotScatter(pbmdat[, colData(pbmdat)$lp == 400])
```

A similar but alternative view of the data is the [MA plot](https://en.wikipedia.org/wiki/MA_plot), which plots the mean log-intensity against the difference in log-intensity for each pair of samples.

```{r, fig.width = 15, fig.height = 5}
pbmPlotScatter(pbmdat[, colData(pbmdat)$lp == 400], maplot = TRUE)
```

Finally, often, we may be interested in comparing across replicates of the same experiment. Here, we illustrate the functionality by comparing conditions across two laser powers. Each sample is matched using a column in the `colData` specified by `match_by = `. Note that the input to `match_by = ` should *not* be quoted.

```{r, fig.width = 15, fig.height = 5}
pbmPlotComparison(pbmdat[, colData(pbmdat)$lp == 400],
                  pbmdat[, colData(pbmdat)$lp == 475],
                  match_by = condition)
```

As above, MA plots are also implemented.

```{r, fig.width = 15, fig.height = 5}
pbmPlotComparison(pbmdat[, colData(pbmdat)$lp == 400],
                  pbmdat[, colData(pbmdat)$lp == 475],
                  match_by = condition,
                  maplot = TRUE)
```

In each of the plots generated above, values are taken from the `"fore"` assay by default. However, background intensities (or any other _assay_) in the _SummarizedExperiment_ can also be plotted by specifying the `assay_name = ` parameter.

```{r, fig.width = 15, fig.height = 5}
pbmPlotDensity(pbmdat, assay_name = "back",
               log_scale = TRUE, .facet = FALSE) +
    facet_grid(lp ~ condition) +
    ggtitle("PBM Background Intensity (log2)")
```

## Pre-Processing GPR Data

**Choice of pre-processing steps for PBM data is still under investigation.**

Approaches for pre-processing of microarray intensities has been widely studied over the past 15 years. Several popular and successful approaches, including RMA, have been implemented and made available through the *affy* and *limma* packages. However, the functions implemented within these packages expect slightly different inputs and generate slighlty different outputs, making it difficult to directly apply the methods to our data stored in *SummarizedExperiment* class. To make access to these functions easier, we have written several wrapper functions to pre-processing functions implemented in both packages.

Single-channal pre-processing includes two primary steps: **within-sample background correction** and **between-sample normalization**. The corresponding functions implemented in *limma* are wrapped as `limmaBackgroundCorrect` and `limmaNormalizeBetweenSamples`. Each function returns the same *SummarizedExperiment* object, but with normalized expression estimates.

The simplest background correction approach is to simply subtract the background intensities from the foreground intensities. This can be done by specifying the background assay name to `assayb_name = "back"` (and optionally `method = "subtract"`). **Currently, we recommend using the "subtract" approach when background intensities are available.**

```{r}
pbmdat_bc <- limmaBackgroundCorrect(pbmdat, assayb_name = "back")
```

If the assay name for the background intensities is not specified, background noise will be estimated using a Normal-Exponential convolution model. (See `help(backgroundCorrect, package = limma)` for more details.)

```{r, eval = FALSE}
## NOT RUN - would use 'normexp' background correction approach
pbmdat_bc <- limmaBackgroundCorrect(pbmdat)
```

Since the returned object is again a SummarizedExperiment, we can easily plot the data using the functions described above. Here, we compare the background corrected and original data for scans at laser power 500.

```{r, fig.width = 15, fig.height = 5}
pbmPlotComparison(pbmdat[, colData(pbmdat)$lp == 400],
                  pbmdat_bc[, colData(pbmdat_bc)$lp == 400])
```

For provenance, the correction step (`limma::backgroundCorrect`) is also noted in the `metadata` of the object along with the name of the modified assay (`fore`). 

```{r}
metadata(pbmdat_bc)
```

We next apply cross-sample normalization. Since a primary objective of normalizing across samples is to put intensities on the same scale, we apply the procedure to only a subset of samples scanned at the same laser intensity. The default is currently to use quantile normalization. **However, based on the observation that samples may have fundamentally different distributional shapes, it is not yet clear if quantile normalization is the best approach for PBM data.** (Again, see `help(normalizeBetweenArrays, package = limma)` for more details.)

```{r}
pbmdat400_norm <- limmaNormalizeBetweenArrays(pbmdat_bc[, colData(pbmdata)$lp == 400])
```

Again, we compare the normalized data against the original data.

```{r, fig.width = 15, fig.height = 5}
pbmPlotComparison(pbmdat_bc[, colData(pbmdat)$lp == 400],
                  pbmdat400_norm, maplot = TRUE)
```

## Filtering GPR Data

**Probe-level filtering procedures are still under investigation.**

## Quantifying GPR Data

After applying pre-processing and filtering to probe-level intensities for each GPR file, we proceed to estimating candidate motif-level affinities. 

# References

- [Berger MF and Bulyk ML (2009). "Universal protein-binding microarrays for the comprehensive characterization of the DNA-binding specificities of transcription factors." Nature Protocols, 4(3):393-411.](http://the_brain.bwh.harvard.edu/pubs/uPBMs_NatProt09.pdf)
- [Berger MF, Philippakis AA, Qureshi A, He FS, Estep PW III and Bulyk ML (2006). "Compact, universal DNA microarrays to comprehensively determine transcription-factor binding site specificities." Nature Biotechnology, 24(11):1429-1435.](http://the_brain.bwh.harvard.edu/pubs/CompactDNAview.pdf)
- [Universal PBM Analysis Suite](the_brain.bwh.harvard.edu/PBMAnalysisSuite/indexSep2017.html)
- [Morgan M, Obenchain V, Hester J and Pagès H (2017). SummarizedExperiment: SummarizedExperiment container. R package version 1.8.1.](https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html)
- [Gautier L, Cope L, Bolstad BM and Irizarry RA (2004). "affy—analysis of Affymetrix GeneChip data at the probe level." Bioinformatics, 20(3):307–315.](https://www.bioconductor.org/packages/release/bioc/html/affy.html)
- [Ritchie ME, Phipson B, Wu D, Hu Y, Law CW, Shi W and Smyth GK (2015). "limma powers differential expression analyses for RNA-sequencing and microarray studies." Nucleic Acids Research, 43(7):e47.](http://bioconductor.org/packages/release/bioc/html/limma.html)
