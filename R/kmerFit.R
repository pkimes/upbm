#' Fit Probe Models
#'
#' @description
#' This function uses limma to estimate probe-level mean and moderated
#' variance estimates across replicates within conditions.
#' 
#' @param se SummarizedExperiment object containing PBM intensity data.
#' @param assay_name string name of the assay to use. (default = "fore")
#' @param groups unquoted name of column in colData of SummarizedExperiment (or
#'        '\code{sample}') for grouping samples; values in columns will be
#'        used as group labels. If no group labels are available, all samples
#'        can be pooled by specifying \code{NULL}. (default = condition)
#' @param offset integer offset to add to intensities before log2 scaling to
#'        prevent errors with zero intensities. If set to 0, probes with
#'        zero intensities are dropped/ignored in estimation. (default = 1)
#' @param .filter integer specifying level of probe filtering to
#'        perform prior to estimating affinities. See \code{pbmFilterProbes}
#'        for more details on probe filter levels. (default = 1)
#' @param .fits logical whether to just return \code{limma} fit rather than
#'        cleaned up SummarizedExperiment object. Used mostly just during
#'        development. (default = FALSE)
#' @param ... named arguments to be passed to \code{limma::eBayes}. See
#'        Details for default parameters used in this function (different from
#'        \code{limma::eBayes} default).
#' 
#' @return
#' SummarizedExperiment object with probe-level intensity information aggregated
#' across replicates. Each assay contains probe-level information for a single
#' group in the specified \code{groups} variable.
#'
#' @md
#' @import SummarizedExperiment
#' @importFrom dplyr left_join distinct
#' @importFrom limma lmFit eBayes
#' @export
#' @author Patrick Kimes
probeFit <- function(se, assay_name = "fore", groups = condition,
                     offset = 1L, .filter = 1L, .fits = FALSE, ...) {
    
    ## define eBayes parameters with defaults
    dots <- list(...)
    eb_args <- list(trend = TRUE, robust = TRUE)
    eb_args <- replace(eb_args, names(dots), dots)

    ## filter probes
    se <- pbmFilterProbes(se, .filter) 

    ## extract probe data matrix
    datp <- assay(se, assay_name)
    datp <- log2(as.matrix(datp) + offset)
    datp[is.infinite(datp)] <- NA

    ## check stratification params
    groups <- rlang::enquo(groups)
    coldat <- .pbmCheckGroups(se, groups)

    ## fit limma model
    fit <- limma::lmFit(datp, coldat)

    ## fit empirical Bayes adjustment with specified parameters
    eb_args$fit <- fit
    fit <- do.call(limma::eBayes, eb_args)

    ## if specified, just return fits
    if (.fits) {
        return(fit)
    }

    ## return SummarizedExperiment with test results - one coef per assay
    alist <- list(beta = fit$coefficients,
                  sd = sweep(fit$stdev.unscaled, 1, fit$s2.post^.5, `*`),
                  df = replicate(ncol(fit$coefficients), fit$df.total))

    SummarizedExperiment(assays = alist, rowData = rowData(se))
}


#' Aggregate K-mer Probe Sets
#'
#' @description
#' After performing probe-level summarization across samples, this function creates
#' a K-mer by probe mapping for a specified list of K-mers. By default, probe
#' affinities are corrected for position bias assuming a consistent position bias
#' pattern, conditional on mean probe intensity for each K-mer. The bias correction
#' is performed such that the mean probe intensity for each K-mer is unchanged.
#' The bias correction is performed to reduce the cross-probe variance within
#' each K-mer probe set for downstream analysis.
#'
#' @param se probe-level affinity summaries generated by \code{probeFit} with each
#'        assay corresponding to a different group label. 
#' @param kmers character vector of k-mers to predict.
#' @param positionbias logical whether to correct for bias due to position
#'        of K-mer along probe sequence. (default = TRUE)
#' @param .filter integer specifying level of probe filtering to
#'        perform prior to estimating affinities. See \code{pbmFilterProbes}
#'        for more details on probe filter levels. (default = 1)
#' @param .trim interger vector of length two specifying start and end
#'        of probe sequence to be used. Default is based on the universal
#'        PBM probe design where only leading 36nt should be used. 
#'        Ignored if NULL. (default = c(1, 36))
#'
#' @return
#' SummarizedExperiment of K-mer, probe pairs.
#'
#' @export
#' @author Patrick Kimes
kmerAggregate <- function(se, kmers, positionbias = TRUE, .filter = 1L,
                          .trim = if (.filter > 0L) { c(1, 36) } else { NULL }) {
    stopifnot(is(se, "SummarizedExperiment"))

    ## check kmers specified
    kmers <- checkKmers(kmers, verb = FALSE)

    ## check Sequence info in rowData
    se <- checkProbeSequences(se, verb = FALSE)

    ## filter probes
    se <- pbmFilterProbes(se, .filter)

    ## trim probe sequences
    se <- trimProbeSequences(se, .trim)

    ## find mapping between kmers and probes
    ovnames <- intersect(names(rowData(se)), c("Row", "Column", "ID", "Sequence"))
    kmermap <- mapKmers(rowData(se)[, ovnames, drop = FALSE], kmers)

    ## use ordering from input 'kmers'
    kmermap$seq <- factor(kmermap$seq, levels = kmers)

    ## create table of probe-level betas
    bdat <- assay2tidy(se, "beta", long = FALSE, .filter = 0L)
    bdat <- dplyr::left_join(kmermap, bdat, by = setdiff(ovnames, "Sequence"))

    if (positionbias) {
        ## reshape table and compute probe-set bias per k-mer
        bdat <- dplyr::select(bdat, -probe_idx, -orient, -Column, -Row, -Sequence)
        bdat <- tidyr::gather(bdat, sample, value, -pos, -ID, -seq)

        bdat <- dplyr::group_by(bdat, seq, sample)
        bdat <- dplyr::mutate(bdat, pmean = mean(value, na.rm = TRUE),
                              pbias = value - pmean)
        bdat <- dplyr::ungroup(bdat)

        ## compute average bias over 2% bins
        bdat <- dplyr::group_by(bdat, sample)
        bdat <- dplyr::mutate(bdat, qbin = as.numeric(ggplot2::cut_number(pbias, 1 / .02)))
        bdat <- dplyr::group_by(bdat, sample, qbin, pos)
        bdat <- dplyr::mutate(bdat, pbias = mean(pbias, na.rm = TRUE))
        bdat <- dplyr::ungroup(bdat)
        bdat <- dplyr::select(bdat, -pmean, -qbin)

        ## create table of adjusted beta estimates, samples as cols (so slow..)
        bdat_beta <- dplyr::select(bdat, seq, pos, ID, sample, value)
        bdat_beta <- tidyr::spread(bdat_beta, sample, value)
        bdat_beta <- dplyr::arrange(bdat_beta, seq, ID, pos)

        ## ## create table of adjusted beta estimates, samples as cols (so slow..)
        ## bdat_pbias <- dplyr::select(bdat, seq, pos, ID, sample, value)
        ## bdat_pbias <- tidyr::spread(bdat_pbias, sample, value)
        ## bdat_pbias <- dplyr::arrange(bdat_pbias, seq, ID, pos)
    } else {
        bdat_beta <- dplyr::select(bdat, seq, pos, ID, one_of(colnames(se)))
        bdat_beta <- dplyr::arrange(bdat_beta, seq, ID, pos)
    }

    ## extract consistent table columns
    rowdat <- dplyr::select(bdat_beta, -one_of(colnames(se)))
    
    ## create table of sd estimates, samples as cols
    bdat_sd <- assay2tidy(se, "sd", long = FALSE, .filter = 0L)
    bdat_sd <- dplyr::select(bdat_sd, -Sequence, -Column, -Row)
    bdat_sd <- dplyr::left_join(rowdat, bdat_sd, by = "ID")
    bdat_sd <- dplyr::arrange(bdat_sd, seq, ID, pos)

    ## turn beta table into DataFrame for SummarizedExperiment object
    a_beta <- dplyr::select(bdat_beta, one_of(colnames(se)))
    a_beta <- DataFrame(a_beta, check.names = FALSE)

    ## turn SD table into DataFrame for SummarizedExperiment object
    a_sd <- dplyr::select(bdat_sd, one_of(colnames(se)))
    a_sd <- DataFrame(a_sd, check.names = FALSE)

    SummarizedExperiment(list(beta = a_beta, sd = a_sd),
                         rowData = DataFrame(rowdat, check.names = FALSE))    
}


#' Fit K-mer Probe Set Models
#'
#' @description
#' After performing probe-level aggregation across samples, this function applies probe
#' set aggregation to obtain K-mer level estimates of affinity. 
#'
#' @param se K-mer level probe set summaries generated by \code{kmerAggregate} with each
#'        assay corresponding to a different group label.
#' @param conditions logical specifying whether K-mer summaries should be returned for
#'        each condition. (default = TRUE)
#' @param contrasts logical specifying whether K-mer summaries should be returned for
#'        each condition contrast. (default = FALSE)
#' @param baseline string name of baseline condition to compare other conditions against;
#'        if not specified and \code{contrasts = TRUE}, baseline is guessed by looking for
#'        'ref' in any of the conditions. (default = NULL)
#' @param method character name of method to use for estimating cross-probe variance
#'        in each K-mer probe set. Currently, the non-iterative DerSimonian-Laird ("dl")
#'        and two-step Dersimonian-Laird ("dl2") methods are supported. (default = "dl2")
#' 
#' @return
#' SummarizedExperiment of estimated K-mer affinities and/or differential affinities.
#'
#' @importFrom dplyr select_ group_by left_join ungroup do mutate
#' @importFrom tidyr unnest spread
#' @export
#' @author Patrick Kimes
kmerFit <- function(se, conditions = TRUE, contrasts = FALSE, baseline = NULL,
                    method = c("dl2", "dl")) {

    method <- match.arg(method)
    stopifnot(is(se, "SummarizedExperiment"))

    ## turn assays into single tibble
    rd <- rowData(se)
    rd <- as.tibble(as.data.frame(rd, optional = TRUE))
    adat <- replicate(ncol(se), rd, simplify = FALSE)
    names(adat) <- colnames(se)
    adat <- bind_rows(adat, .id = "condition")
    adat$beta <- as.numeric(as.matrix(assay(se, "beta")))
    adat$sd <- as.numeric(as.matrix(assay(se, "sd")))

    ## only keep necessary columns
    adat <- dplyr::select(adat, condition, seq, beta, sd)

    ## compute probe set mixed effects model for each k-mer and condition
    adat <- tidyr::nest(adat, -condition, -seq)
    if (method == "dl") {
        adat <- dplyr::mutate(adat, res = lapply(data, function(x) {
            dl_estimator(x$beta, x$sd^2, nrow(x))
        }))
    } else if (method == "dl2") {
        adat <- dplyr::mutate(adat, res = lapply(data, function(x) {
            dl2_estimator(x$beta, x$sd^2, nrow(x))
        }))
    } else {
        stop("specified method is invalid")
    }
    adat <- dplyr::select(adat, -data)

    ## tidy results to assays
    alist <- list(betaFE = .tidymat_alt(adat, kmers, "betaFE"),
                  varFE = .tidymat_alt(adat, kmers, "varFE"),
                  betaME = .tidymat_alt(adat, kmers, "betaME"),
                  varME = .tidymat_alt(adat, kmers, "varME"),
                  tau2 = .tidymat_alt(adat, kmers, "tau2"))

    rdat <- dplyr::select(adat, seq)
    rdat <- rdat[match(kmers, rdat$seq), ]

    SummarizedExperiment(assays = alist, rowData = rdat)
}


.tidymat_alt <-  function (x, km, cn) {
    x <- dplyr::mutate(x, value = vapply(res, `[[`, numeric(1), cn))
    x <- dplyr::select(x, seq, condition, value)
    x <- tidyr::spread(x, condition, value)
    x <- x[match(km, x$seq), sort(names(x))]
    as.matrix(dplyr::select(x, -seq))
}

.pbmCheckGroups <- function(s, grp) {
    grp_str <- rlang::quo_name(grp)

    coldat <- data.frame(colData(s), check.names = FALSE,
                         check.rows = FALSE, stringsAsFactors = FALSE)
    coldat <- tibble::rownames_to_column(coldat, "sample")

    ## check validity of grouping colData column
    if (! grp_str %in% names(colData(s))) {
        if (grp_str != "NULL") {
            stop("Specified Group must be unquoted column in colData or NULL.")
        }
        coldat <- dplyr::mutate(coldat, Groups = "allsamples")
    } else {
        coldat <- dplyr::mutate(coldat, Groups = !!grp)
    }
    
    coldat <- dplyr::select(coldat, sample, Groups)
    coldat <- dplyr::mutate(coldat, z = 1)
    coldat <- tidyr::spread(coldat, Groups, z, fill = 0)
    
    rord <- coldat$sample
    coldat <- dplyr::select(coldat, -sample)
    coldat <- as.matrix(coldat)
    coldat[match(colnames(s), rord), , drop = FALSE]
}

## source: `metafor` CRAN package, R/misc.func.hidden.r (git hash: f037e1b)
.invcalc <- function(X, W, k) {
   sWX <- sqrt(W) %*% X
   res.qrs <- qr.solve(sWX, diag(k))
   return(tcrossprod(res.qrs))
}

#' DerSimonian and Laird Estimator
#'
#' @description
#' This is an implementation of the DerSimonian and Laird one step estimator of
#' cross-study variance, originally proposed in the context of meta analysis,
#' adapted from the \code{metafor} package. The function is used to estimate
#' the cross-probe variance for each K-mer probe set.  
#' 
#' @param Y probe effect sizes
#' @param vi probe variances
#' @param k number of probes
#'
#' @return
#' list of estimates:
#' \itemize{
#' \item betaFE: effect size with no cross-study variance
#' \item varFE: total variance with no cross-study variance
#' \item betaME: effect size with cross-study variance
#' \item varME: total variance with cross-study variance
#' \item tau2: cross-study variance 
#' }
#'
#' @references
#' \itemize{
#' \item DerSimonian, R., & Laird, N. (1986). Meta-analysis in clinical trials. Controlled Clinical Trials, 7(3), 177-188.
#' \item Viechtbauer, W. (2010). Conducting meta-analyses in R with the metafor package. Journal of Statistical Software, 36(3), 1-48. URL: http://www.jstatsoft.org/v36/i03/
#' }
#' 
#' @export 
#' @author Patrick Kimes
dl_estimator <- function(Y, vi, k) {
    X     <- rep(1, k)
    p     <- 1
    
    wi    <- 1/vi
    W     <- diag(wi, nrow = k, ncol = k)
    stXWX <- .invcalc(X = X, W = W, k = k)
    stXWX_tXW <- stXWX %*% crossprod(X, W)
    P     <- W - W %*% X %*% stXWX_tXW
    RSS   <- crossprod(Y, P) %*% Y
    trP   <- sum(diag(P))

    tau2  <- max((RSS - k + p) / trP, 0)
    
    betaFE  <- as.numeric(stXWX_tXW %*% Y)
    varFE <- 1 / sum(wi)

    if (tau2 > 0) {
        W_     <- diag(1 / (vi + tau2), nrow = k, ncol = k)
        M_     <- diag(vi + tau2, nrow = k, ncol = k)
        stXWX_ <- .invcalc(X = X, W = W_, k = k)
        betaME  <- as.numeric(stXWX_ %*% crossprod(X, W_) %*% Y)
        varME <- diag(stXWX_)
    } else {
        betaME <- betaFE
        varME <- varFE
    }
    list(betaFE = betaFE, varFE = varFE,
         betaME = betaME, varME = varME,
         tau2 = tau2)
}

#' Two-Step DerSimonian aand Kacker Estimator
#'
#' @description
#' This is an implementation of the DerSimonian and Kacker two-step estimator of
#' cross-study variance, originally proposed as an improvement over the one-step
#' DerSimonian and Laird estimator in the context of meta analysis.
#' 
#' @param Y probe effect sizes
#' @param vi probe variances
#' @param k number of probes
#'
#' @return
#' list of estimates:
#' \itemize{
#' \item betaFE: effect size with no cross-study variance
#' \item varFE: total variance with no cross-study variance
#' \item betaME: effect size with cross-study variance
#' \item varME: total variance with cross-study variance
#' \item tau2: cross-study variance 
#' }
#' 
#' @references
#' \itemize{
#' \item DerSimonian, R., & Kacker, R. (2007). Random-effects model for meta-analysis of clinical trials: an update. Contemporary Clinical Trials, 28(2), 105-114.
#' }
#' 
#' @export 
#' @author Patrick Kimes
dl2_estimator <- function(Y, vi, k) {
    X   <- rep(1, k)
    p   <- 1
    res <- dl_estimator(Y, vi, k)
    
    wi    <- 1 / (vi + res$tau2)
    W     <- diag(wi, nrow = k, ncol = k)
    stXWX <- .invcalc(X = X, W = W, k = k)
    stXWX_tXW <- stXWX %*% crossprod(X, W)
    P     <- W - W %*% X %*% stXWX_tXW
    RSS   <- crossprod(Y, P) %*% Y
    trP   <- sum(diag(P))

    SSE <- sum(wi * vi) - sum(wi^2 * vi) / sum(wi)
    tau2  <- max((RSS - SSE) / trP, 0)

    betaFE  <- as.numeric(stXWX_tXW %*% Y)
    varFE <- 1 / sum(wi)
    
    if (tau2 > 0) {
        W_     <- diag(1 / (vi + tau2), nrow = k, ncol = k)
        M_     <- diag(vi + tau2, nrow = k, ncol = k)
        stXWX_ <- .invcalc(X = X, W = W_, k = k)
        betaME  <- as.numeric(stXWX_ %*% crossprod(X, W_) %*% Y)
        varME <- diag(stXWX_)
    } else {
        betaME <- betaFE
        varME <- varFE
    }
    list(betaFE = betaFE, varFE = varFE,
         betaME = betaME, varME = varME,
         tau2 = tau2)
}


