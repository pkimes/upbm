#' Fit Probe Models
#'
#' @description
#' This function uses limma to estimate probe-level mean and moderated
#' variance estimates across replicates within conditions.
#' 
#' @param se SummarizedExperiment object containing PBM intensity data.
#' @param assay_name string name of the assay to use. (default = "fore")
#' @param groups unquoted name of column in colData of SummarizedExperiment (or
#'        '\code{sample}') for grouping samples; values in columns will be
#'        used as group labels. If no group labels are available, all samples
#'        can be pooled by specifying \code{NULL}. (default = condition)
#' @param offset integer offset to add to intensities before log2 scaling to
#'        prevent errors with zero intensities. If set to 0, probes with
#'        zero intensities are dropped/ignored in estimation. (default = 1)
#' @param .filter integer specifying level of probe filtering to
#'        perform prior to estimating affinities. See \code{pbmFilterProbes}
#'        for more details on probe filter levels. (default = 1)
#' @param .fits logical whether to just return \code{limma} fit rather than
#'        cleaned up SummarizedExperiment object. Used mostly just during
#'        development. (default = FALSE)
#' @param ... named arguments to be passed to \code{limma::eBayes}. See
#'        Details for default parameters used in this function (different from
#'        \code{limma::eBayes} default).
#' 
#' @return
#' SummarizedExperiment object with probe-level intensity information aggregated
#' across replicates. Each assay contains probe-level information for a single
#' group in the specified \code{groups} variable.
#'
#' @md
#' @import SummarizedExperiment
#' @importFrom dplyr left_join distinct
#' @importFrom limma lmFit eBayes
#' @export
#' @author Patrick Kimes
probeFit <- function(se, assay_name = "fore", groups = condition,
                     offset = 1L, .filter = 1L, .fits = FALSE, ...) {
    
    ## define eBayes parameters with defaults
    dots <- list(...)
    eb_args <- list(trend = TRUE, robust = TRUE)
    eb_args <- replace(eb_args, names(dots), dots)

    ## filter probes
    se <- pbmFilterProbes(se, .filter) 

    ## extract probe data matrix
    datp <- assay(se, assay_name)
    datp <- log2(as.matrix(datp) + offset)
    datp[is.infinite(datp)] <- NA

    ## check stratification params
    groups <- rlang::enquo(groups)
    coldat <- .pbmCheckGroups(se, groups)

    ## fit limma model
    fit <- limma::lmFit(datp, coldat)

    ## fit empirical Bayes adjustment with specified parameters
    eb_args$fit <- fit
    fit <- do.call(limma::eBayes, eb_args)

    ## if specified, just return fits
    if (.fits) {
        return(fit)
    }

    ## return SummarizedExperiment with test results - one coef per assay
    alist <- list(beta = fit$coefficients,
                  sd = sweep(fit$stdev.unscaled, 1, fit$s2.post^.5, `*`),
                  df = replicate(ncol(fit$coefficients), fit$df.total))

    SummarizedExperiment(assays = alist, rowData = rowData(se))
}


#' Aggregate K-mer Probe Sets
#'
#' @description
#' After performing probe-level summarization across samples, this function creates
#' a K-mer by probe mapping for a specified list of K-mers. By default, probe
#' affinities are corrected for position bias assuming a consistent position bias
#' pattern, conditional on mean probe intensity for each K-mer. The bias correction
#' is performed such that the mean probe intensity for each K-mer is unchanged.
#' The bias correction is performed to reduce the cross-probe variance within
#' each K-mer probe set for downstream analysis.
#'
#' @param se probe-level affinity summaries generated by \code{probeFit} with each
#'        assay corresponding to a different group label. 
#' @param kmers character vector of k-mers to predict.
#' @param positionbias logical whether to correct for bias due to position
#'        of K-mer along probe sequence. (default = TRUE)
#' @param .filter integer specifying level of probe filtering to
#'        perform prior to estimating affinities. See \code{pbmFilterProbes}
#'        for more details on probe filter levels. (default = 1)
#' @param .trim interger vector of length two specifying start and end
#'        of probe sequence to be used. Default is based on the universal
#'        PBM probe design where only leading 36nt should be used. 
#'        Ignored if NULL. (default = c(1, 36))
#'
#' @return
#' SummarizedExperiment of K-mer, probe pairs.
#'
#' @export
#' @author Patrick Kimes
kmerAggregate <- function(se, kmers, positionbias = TRUE, .filter = 1L,
                          .trim = if (.filter > 0L) { c(1, 36) } else { NULL }) {
    stopifnot(is(se, "SummarizedExperiment"))

    ## check kmers specified
    kmers <- checkKmers(kmers, verb = FALSE)

    ## check Sequence info in rowData
    se <- checkProbeSequences(se, verb = FALSE)

    ## filter probes
    se <- pbmFilterProbes(se, .filter)

    ## trim probe sequences
    se <- trimProbeSequences(se, .trim)

    ## find mapping between kmers and probes
    ovnames <- intersect(names(rowData(se)), c("Row", "Column", "ID", "Sequence"))
    kmermap <- mapKmers(rowData(se)[, ovnames, drop = FALSE], kmers)

    ## use ordering from input 'kmers'
    kmermap$seq <- factor(kmermap$seq, levels = kmers)

    ## create table of probe-level betas
    bdat <- assay2tidy(se, "beta", long = FALSE, .filter = 0L)
    bdat <- dplyr::left_join(kmermap, bdat, by = setdiff(ovnames, "Sequence"))

    if (positionbias) {
        ## reshape table and compute probe-set bias per k-mer
        bdat <- dplyr::select(bdat, -probe_idx, -orient, -Column, -Row, -Sequence)
        bdat <- tidyr::gather(bdat, sample, value, -pos, -ID, -seq)

        bdat <- dplyr::group_by(bdat, seq, sample)
        bdat <- dplyr::mutate(bdat, pmean = mean(value, na.rm = TRUE),
                              pbias = value - pmean)
        bdat <- dplyr::ungroup(bdat)

        ## compute average bias over 2% bins
        bdat <- dplyr::group_by(bdat, sample)
        bdat <- dplyr::mutate(bdat, qbin = as.numeric(ggplot2::cut_number(pbias, 1 / .02)))
        bdat <- dplyr::group_by(bdat, sample, qbin, pos)
        bdat <- dplyr::mutate(bdat, pbias = mean(pbias, na.rm = TRUE))
        bdat <- dplyr::ungroup(bdat)
        bdat <- dplyr::select(bdat, -pmean, -qbin)

        ## create table of adjusted beta estimates, samples as cols (so slow..)
        bdat_beta <- dplyr::select(bdat, seq, pos, ID, sample, value)
        bdat_beta <- tidyr::spread(bdat_beta, sample, value)
        bdat_beta <- dplyr::arrange(bdat_beta, seq, ID, pos)

        ## ## create table of adjusted beta estimates, samples as cols (so slow..)
        ## bdat_pbias <- dplyr::select(bdat, seq, pos, ID, sample, value)
        ## bdat_pbias <- tidyr::spread(bdat_pbias, sample, value)
        ## bdat_pbias <- dplyr::arrange(bdat_pbias, seq, ID, pos)
    } else {
        bdat_beta <- dplyr::select(bdat, seq, pos, ID, one_of(colnames(se)))
        bdat_beta <- dplyr::arrange(bdat_beta, seq, ID, pos)
    }

    ## extract consistent table columns
    rowdat <- dplyr::select(bdat_beta, -one_of(colnames(se)))
    
    ## create table of sd estimates, samples as cols
    bdat_sd <- assay2tidy(se, "sd", long = FALSE, .filter = 0L)
    bdat_sd <- dplyr::select(bdat_sd, -Sequence, -Column, -Row)
    bdat_sd <- dplyr::left_join(rowdat, bdat_sd, by = "ID")
    bdat_sd <- dplyr::arrange(bdat_sd, seq, ID, pos)

    ## turn beta table into DataFrame for SummarizedExperiment object
    a_beta <- dplyr::select(bdat_beta, one_of(colnames(se)))
    a_beta <- DataFrame(a_beta, check.names = FALSE)

    ## turn SD table into DataFrame for SummarizedExperiment object
    a_sd <- dplyr::select(bdat_sd, one_of(colnames(se)))
    a_sd <- DataFrame(a_sd, check.names = FALSE)

    SummarizedExperiment(list(beta = a_beta, sd = a_sd),
                         rowData = DataFrame(rowdat, check.names = FALSE))    
}


#' Fit K-mer Probe Set Models
#'
#' @description
#' After performing probe-level aggregation across samples, this function applies probe
#' set aggregation to obtain K-mer level estimates of affinity. 
#'
#' @param se K-mer level probe set summaries generated by \code{kmerAggregate} with each
#'        assay corresponding to a different group label.
#' @param conditions logical specifying whether K-mer summaries should be returned for
#'        each condition. (default = TRUE)
#' @param contrasts logical specifying whether K-mer summaries should be returned for
#'        each condition contrast. (default = FALSE)
#' @param baseline string name of baseline condition to compare other conditions against;
#'        if not specified and \code{contrasts = TRUE}, baseline is guessed by looking for
#'        'ref' in any of the conditions. (default = NULL)
#'
#' @return
#' SummarizedExperiment of estimated K-mer affinities and/or differential affinities.
#'
#' @importFrom dplyr select_ group_by left_join ungroup do mutate
#' @importFrom tidyr unnest spread
#' @export
#' @author Patrick Kimes
kmerFit <- function(se, conditions = TRUE, contrasts = FALSE, baseline = NULL) {

}


.pbmCheckGroups <- function(s, grp) {
    grp_str <- rlang::quo_name(grp)

    coldat <- data.frame(colData(s), check.names = FALSE,
                         check.rows = FALSE, stringsAsFactors = FALSE)
    coldat <- tibble::rownames_to_column(coldat, "sample")

    ## check validity of grouping colData column
    if (! grp_str %in% names(colData(s))) {
        if (grp_str != "NULL") {
            stop("Specified Group must be unquoted column in colData or NULL.")
        }
        coldat <- dplyr::mutate(coldat, Groups = "allsamples")
    } else {
        coldat <- dplyr::mutate(coldat, Groups = !!grp)
    }
    
    coldat <- dplyr::select(coldat, sample, Groups)
    coldat <- dplyr::mutate(coldat, z = 1)
    coldat <- tidyr::spread(coldat, Groups, z, fill = 0)
    
    rord <- coldat$sample
    coldat <- dplyr::select(coldat, -sample)
    coldat <- as.matrix(coldat)
    coldat[match(colnames(s), rord), , drop = FALSE]
}

