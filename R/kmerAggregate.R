#' Aggregate k-mer Probe Sets
#'
#' @description
#' After performing probe-level summarization across samples, this function creates
#' a k-mer by probe mapping for a specified list of k-mers. By default, probe
#' affinities are corrected for position bias assuming a consistent position bias
#' pattern, conditional on mean probe intensity for each k-mer. The bias correction
#' is performed such that the mean probe intensity for each k-mer is unchanged.
#' The bias correction is performed to reduce the cross-probe variance within
#' each k-mer probe set for downstream analysis.
#'
#' @param se SummarizedExpeirment of probe-level affinity summaries generated by
#'         \code{probeFit}.
#' @param kmers character vector of k-mers to predict.
#' @param positionbias logical whether to correct for bias due to position
#'        of k-mer along probe sequence. (default = TRUE)
#' @param .filter integer specifying level of probe filtering to
#'        perform prior to estimating affinities. See \code{pbmFilterProbes}
#'        for more details on probe filter levels. (default = 1)
#' @param .trim interger vector of length two specifying start and end
#'        of probe sequence to be used. Default is based on the universal
#'        PBM probe design where only leading 36nt should be used. 
#'        Ignored if NULL. (default = c(1, 36))
#'
#' @return
#' SummarizedExperiment of k-mer, probe pairs.
#'
#' @export
#' @author Patrick Kimes
kmerAggregate <- function(se, kmers, positionbias = TRUE, .filter = 1L,
                          .trim = if (.filter > 0L) { c(1, 36) } else { NULL }) {
    stopifnot(is(se, "SummarizedExperiment"))

    ## check kmers specified
    kmers <- checkKmers(kmers, verb = FALSE)

    ## check Sequence info in rowData
    se <- checkProbeSequences(se, verb = FALSE)

    ## filter probes
    se <- pbmFilterProbes(se, .filter)

    ## trim probe sequences
    se <- trimProbeSequences(se, .trim)

    ## find mapping between kmers and probes
    ovnames <- intersect(names(rowData(se)), c("Row", "Column", "ID", "Sequence"))
    kmermap <- mapKmers(rowData(se)[, ovnames, drop = FALSE], kmers)

    ## use ordering from input 'kmers'
    kmermap$seq <- factor(kmermap$seq, levels = kmers)

    ## create table of probe-level betas
    bdat <- tidy.SummarizedExperiment(se, "beta", long = FALSE, .filter = 0L)
    bdat <- dplyr::left_join(kmermap, bdat, by = setdiff(ovnames, "Sequence"))

    if (positionbias) {
        ## reshape table and compute probe-set bias per k-mer
        bdat <- dplyr::select(bdat, -probe_idx, -orient, -Column, -Row, -Sequence)
        bdat <- tidyr::gather(bdat, sample, value, -pos, -ID, -seq)

        bdat <- dplyr::group_by(bdat, seq, sample)
        bdat <- dplyr::mutate(bdat, pmean = mean(value, na.rm = TRUE),
                              pbias = value - pmean)
        bdat <- dplyr::ungroup(bdat)

        ## compute average bias over 2% bins
        bdat <- dplyr::group_by(bdat, sample)
        bdat <- dplyr::mutate(bdat, qbin = as.numeric(ggplot2::cut_number(pmean, 1 / .02)))
        bdat <- dplyr::group_by(bdat, sample, qbin, pos)
        bdat <- dplyr::mutate(bdat, pbias = mean(pbias, na.rm = TRUE))
        bdat <- dplyr::ungroup(bdat)
        bdat <- dplyr::mutate(bdat, value = value - pbias)
        bdat <- dplyr::select(bdat, -pmean, -qbin)

        ## create table of adjusted beta estimates, samples as cols (so slow..)
        bdat_beta <- dplyr::select(bdat, seq, pos, ID, sample, value)
        bdat_beta <- tidyr::spread(bdat_beta, sample, value)
        bdat_beta <- dplyr::arrange(bdat_beta, seq, ID, pos)

        ## ## create table of adjusted beta estimates, samples as cols (so slow..)
        ## bdat_pbias <- dplyr::select(bdat, seq, pos, ID, sample, value)
        ## bdat_pbias <- tidyr::spread(bdat_pbias, sample, value)
        ## bdat_pbias <- dplyr::arrange(bdat_pbias, seq, ID, pos)
    } else {
        bdat_beta <- dplyr::select(bdat, seq, pos, ID, one_of(colnames(se)))
        bdat_beta <- dplyr::arrange(bdat_beta, seq, ID, pos)
    }

    ## extract consistent table columns
    rowdat <- dplyr::select(bdat_beta, -one_of(colnames(se)))
    
    ## create table of sd estimates, samples as cols
    bdat_sd <- tidy.SummarizedExperiment(se, "sd", long = FALSE, .filter = 0L)
    bdat_sd <- dplyr::select(bdat_sd, -Sequence, -Column, -Row)
    bdat_sd <- dplyr::left_join(rowdat, bdat_sd, by = "ID")
    bdat_sd <- dplyr::arrange(bdat_sd, seq, ID, pos)

    ## turn beta table into DataFrame for SummarizedExperiment object
    a_beta <- dplyr::select(bdat_beta, one_of(colnames(se)))
    a_beta <- DataFrame(a_beta, check.names = FALSE)

    ## turn SD table into DataFrame for SummarizedExperiment object
    a_sd <- dplyr::select(bdat_sd, one_of(colnames(se)))
    a_sd <- DataFrame(a_sd, check.names = FALSE)

    SummarizedExperiment(list(beta = a_beta, sd = a_sd),
                         rowData = DataFrame(rowdat, check.names = FALSE))    
}

