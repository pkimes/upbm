#' @title Compute Cy3 Scaling Factors using Emprical Reference
#'
#' @description
#' PBM arrays are scanned twice, once for Cy3-tagged dUTPs to quantify
#' dsDNA abundance at each probe, and again for the Alexa488-tagged 
#' protein. The Cy3 scans can be used to first filter out probes which
#' appear to have poor dsDNA enrichment, and second, to scale Alexa488
#' intensities to account for differences in dsDNA abundance between
#' probes.
#'
#' Since probe intensities in the Cy3 scans are independent of the
#' loaded Alexa488-tagged protein, Cy3 scans should be comparable across
#' experiments. Based on this observation, a global Cy3 reference can be
#' constructed by taking the empirical average over a large number of Cy3
#' scans. Filtering and scaling can then be performed based on deviations
#' from this reference. Given a SummarizedExperiment of Cy3 scans and an
#' empirical reference generated by \code{cy3GenerateRef}, this function
#' returns the residuals from thereference, and the corresponding
#' observed-expected ratios for each probe as new assays added to the
#' original Cy3 SummarizedExperiment object.
#'
#' The returned SummarizedExperiment object can be passed to \code{cy3Normalize}
#' to filter low quality probes and/or normalize Alexa488 intensities by the
#' computed ratios.
#' 
#' @param se SummarizedExperiment object containing PBM Cy3 intensity data.
#' @param refse SummarizedExperiment object containing PBM Cy3 reference
#'        intensities.
#' @param assay string name of the assay to use. (default = \code{SummarizedExperiment::assayNames(se)[1]})
#' @param useMean logical whether to use the probe-level mean, rather than
#'        the probe-level median as the Cy3 reference (default = TRUE)
#' @param standardize logical whether to standardize residuals using
#'        MAD (median absolute deviation about the median) intensity
#'        computed for PBM Cy3 reference data. (default = TRUE)
#' @param threshold numeric threshold on absolute value of log2 ratio between
#'        observed and expected Cy3 intensities. If \code{standardize} is
#'        specified, the log2 ratios are first scaled before comparing against
#'        the threshold. In this case, the threshold is also scaled by the
#'        median of the probe-level MAD intensities. (default = 1L)
#' @param .filter integer specifying level of probe filtering to
#'        perform prior to estimating affinities. See \code{pbmFilterProbes}
#'        for more details on probe filter levels. (default = 1L)
#'
#' @return
#' original SummarizedExperiment object with additional assays corresponding
#' to ratio of observed vs. expected probe intensities, and whether probes were
#' flagged as low-quality based on abs(log2(ratio)) > \code{threshold}.
#'
#' @seealso cy3GenerateRef cy3Normalize
#' @importFrom dplyr as_tibble select bind_cols group_by ungroup left_join mutate one_of
#' @importFrom tidyr gather spread
#' @export
#' @author Patrick Kimes
cy3FitEmpirical <- function(se, refse, assay = SummarizedExperiment::assayNames(se)[1],
                            useMean = TRUE, standardize = TRUE, threshold = 1L, .filter = 1L) {

    ## filter probes
    nse <- pbmFilterProbes(se, .filter)

    ## check validity of Cy3 empirical reference
    stopifnot("ref" %in% SummarizedExperiment::assayNames(refse))
    stopifnot("sfactor" %in% names(metadata(refse)))
    stopifnot("params" %in% names(metadata(refse)))
    stopifnot("probe_mad" %in% colnames(refse))
    if (useMean) {
        stopifnot("probe_mean" %in% colnames(refse))
    } else {
        stopifnot("probe_median" %in% colnames(refse))
    }

    ## detemrine 
    ovnames1 <- intersect(names(rowData(nse)), c("Row", "Column", "ID"))
    ovnames2 <- intersect(names(rowData(refse)), c("Row", "Column", "ID"))
    ovnames <- intersect(ovnames1, ovnames2)

    ## determine row/probe metadata for Cy3 scans
    rowdat1 <- as.data.frame(rowData(nse), optional = TRUE)
    rowdat1 <- dplyr::as_tibble(rowdat1)
    rowdat1 <- dplyr::select(rowdat1, one_of(ovnames1))

    ## check 'se' rowData alone is alright
    if (nrow(rowdat1) > nrow(dplyr::distinct(rowdat1))) {
        stop("rowData of 'se' cannot be used to uniquely identify probes.\n",
             "Check that rowData contains 'Row', 'Column', and/or 'ID' columns ",
             "which are unique to each probe.")
    }
    
    ## determine row/probe metadata for Cy3 reference
    rowdat2 <- as.data.frame(rowData(refse), optional = TRUE)
    rowdat2 <- dplyr::as_tibble(rowdat2)
    rowdat2 <- dplyr::select(rowdat2, one_of(ovnames2))

    ## check 'refse' rowData alone is alright
    if (nrow(rowdat2) > nrow(dplyr::distinct(rowdat2))) {
        stop("rowData of 'refse' cannot be used to uniquely identify probes.\n",
             "Check that rowData contains 'Row', 'Column', and/or 'ID' columns ",
             "which are unique to each probe.")
    }

    ## check that merging shouldn't be a problem
    if (nrow(rowdat1) > nrow(dplyr::distinct(dplyr::select(rowdat1, one_of(ovnames)))) |
        nrow(rowdat2) > nrow(dplyr::distinct(dplyr::select(rowdat2, one_of(ovnames))))) {
        stop("rowData of 'se' and 'refse' cannot be matched using available rowData columns.\n",
             "Check that rowData contains sufficient 'Row', 'Column', and/or 'ID' columns.\n",
             "'se' rowData: ", paste0(ovnames1, collapse = ", "), "\n",
             "'refse' rowData: ", paste0(ovnames2, collapse = ", "))
    }


    ## extract intensities for Cy3 scans
    pdat1 <- SummarizedExperiment::assay(nse, assay)
    pdat1 <- as.data.frame(pdat1, optional = TRUE)
    pdat1 <- dplyr::as_tibble(pdat1)
    pdat1 <- dplyr::bind_cols(pdat1, rowdat1)
    pdat1 <- tidyr::gather(pdat1, condition, intensity, colnames(nse))

    ## extract intensities for Cy3 reference
    pdat2 <- SummarizedExperiment::assay(refse, "ref")
    pdat2 <- as.data.frame(pdat2, optional = TRUE)
    pdat2 <- dplyr::as_tibble(pdat2)
    pdat2 <- dplyr::bind_cols(pdat2, rowdat2)


    ## join observed and reference tables
    pdat <- dplyr::left_join(pdat1, pdat2, by = ovnames)

    ## set the probe reference 
    if (useMean) {
        pdat$probe_ref <- pdat$probe_mean
    } else {
        pdat$probe_ref <- pdat$probe_median
    }

    ## verify that most values aren't NAs
    pna <- mean(is.na(pdat$probe_ref))
    if (pna > 0.2) {
        stop("After merging observed and reference Cy3 intensities, > 20% of probes have NA reference intensities.\n",
             "Percent NAs = ", 100*round(pna, 4), "%.\n",
             "Please check 'refse' again before proceeding.")
    } else if (pna > 0.01) {
        warning("After merging observed and reference Cy3 intensities, > 1% of probes have NA reference intensities.\n",
                "Percent NAs = ", 100*round(pna, 4), "%.\n")
    }
    
    ## register samples if Cy3 ref was computed with registered scans
    if (metadata(refse)$params$register) {
        pdat <- dplyr::group_by(pdat, condition)
        pdat <- dplyr::mutate(pdat, sintensity = intensity / median(intensity, na.rm = TRUE))
        pdat <- dplyr::ungroup(pdat)
        pdat <- dplyr::mutate(pdat, sintensity = sintensity * metadata(refse)$sfactor)
    } else {
        pdat <- dplyr::mutate(pdat, sintensity = intensity)
    }

    ## log2 tranform and compute ratios
    pdat <- dplyr::mutate(pdat, sintensity = log2(sintensity + metadata(refse)$params$offset))
    pdat <- dplyr::mutate(pdat, pscores = sintensity - probe_ref)
    pdat <- dplyr::mutate(pdat, pratios = 2^pscores)

    ## scale threshold cutoff if standardize specified
    if (standardize) {
        median_mad <- median(SummarizedExperiment::assay(refse, "ref")$probe_mad, na.rm = TRUE)
        pdat <- dplyr::mutate(pdat, pscores = pscores / probe_mad * median_mad)
    }

    ## identify outlier probes
    pdat <- dplyr::mutate(pdat, pdrop = abs(pscores) > threshold)

    
    ## create assays
    pexps <- dplyr::select(pdat, one_of(ovnames), condition, probe_ref)
    pexps <- dplyr::mutate(pexps, probe_ref = 2^probe_ref - metadata(refse)$params$offset)
    pexps <- tidyr::spread(pexps, condition, probe_ref)
    pratios <- dplyr::select(pdat, one_of(ovnames), condition, pratios)
    pratios <- tidyr::spread(pratios, condition, pratios)
    pscores <- dplyr::select(pdat, one_of(ovnames), condition, pscores)
    pscores <- tidyr::spread(pscores, condition, pscores)
    plowq <- dplyr::select(pdat, one_of(ovnames), condition, pdrop)
    plowq <- tidyr::spread(plowq, condition, pdrop)

    
    ## left join to original rowData to get full set
    full_rowdat <- as.data.frame(rowData(se), optional = TRUE)
    full_rowdat <- dplyr::as_tibble(full_rowdat)
    full_rowdat <- dplyr::select(full_rowdat, one_of(ovnames1))

    pexps <- dplyr::left_join(dplyr::select(full_rowdat, one_of(ovnames)), pexps, by = ovnames)
    pratios <- dplyr::left_join(dplyr::select(full_rowdat, one_of(ovnames)), pratios, by = ovnames)
    pscores <- dplyr::left_join(dplyr::select(full_rowdat, one_of(ovnames)), pscores, by = ovnames)
    plowq <- dplyr::left_join(dplyr::select(full_rowdat, one_of(ovnames)), plowq, by = ovnames)

    pexps <- DataFrame(pexps, check.names = FALSE)
    pexps <- pexps[, rownames(colData(se)), drop = FALSE]
    pratios <- DataFrame(pratios, check.names = FALSE)
    pratios <- pratios[, rownames(colData(se)), drop = FALSE]
    pscores <- DataFrame(pscores, check.names = FALSE)
    pscores <- pscores[, rownames(colData(se)), drop = FALSE]
    plowq <- DataFrame(plowq, check.names = FALSE)
    plowq <- plowq[, rownames(colData(se)), drop = FALSE]

    
    ## add to SE object
    SummarizedExperiment::assay(se, "expected") <- pexps
    SummarizedExperiment::assay(se, "ratio") <- pratios
    SummarizedExperiment::assay(se, "scores") <- pscores
    SummarizedExperiment::assay(se, "lowq") <- plowq

    return(se)
}
