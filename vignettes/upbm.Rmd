---
title: "upbm: Analysis of Protein Binding Microarrays in R"
author: Patrick K. Kimes
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('upbm')`"
abstract: >
  "Protein binding microarrays (PBMs) allow for the high-throughput quantification of DNA binding specificities of proteins, e.g. transcription factors, in vitro. While several probe designs have been proposed for PBMs, universal-design PBMs (uPBMs) which cover all 10-mer DNA sequences, have enjoyed the most wide-spread use and success. The *upbm* package provides tools and methods for organizing probe-level PBM data from raw GPR scan files, summarizing PBM data at k-mer resolution, and performing statistical inference when replicate experiments are available. The package was developed for the analysis of uPBMs, but should be appropriate for most other PBM designs as well. upbm package version: `r packageVersion("upbm")`"
output:
  BiocStyle::html_document:
    highlight: pygments
    toc: true
    fig_width: 12
    fig_height: 4
vignette: >
  %\VignetteIndexEntry{upbm: introduction}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r echo=FALSE, include=FALSE}
knitr::opts_chunk$set(tidy = FALSE, cache = TRUE, dev = "png",
                      message = FALSE, error = FALSE, warning = TRUE)
```

# Introduction

While a large collection of methods and software packages have been developed for the processing and analysis of traditional DNA microarrays, the development of tools for protein binding microarrays (PBMs) has been limited. Due to the substantial difference of what is being measured by PBMs (protein-DNA binding) and DNA microarrays (nucleic acid hybridization), blindly applying DNA microarray tools to PBM data can lead to unexpected problems. 

This package provides tools and methods for reading, plotting, and analyzing protein binding microarray (PBM) data in *R* using standard [*Bioconductor*](https://www.bioconductor.org/) [data structures](http://bioconductor.org/developers/how-to/commonMethodsAndClasses/). The primary focus is on universal-design PBMs (uPBMs) which provide approximately uniform coverage of all 8-mer DNA sequences across probes on the array [@berger2006].

# Related Work

A separate set of tools developed in Perl for the analysis of universal-design PBMs (uPBMs) is available for download at the [*Universal PBM Analysis Suite* site](the_brain.bwh.harvard.edu/PBMAnalysisSuite/indexSep2017.html) [@berger2009]. The *upbm* package builds on the work of the *Universal PBM Analysis Suite*, and provides alternative summaries of uPBM data not developed as part of the original suite of tools.

A primary purpose of both software packages is the summarization of DNA binding affinities at the level of individual K-mers. To this end, the *Universal PBM Analysis Suite* summarizes K-mer binding affinity for individual PBM samples with two metrics: a non-parametric rank-based enrichment score (E-score), and the cross-probe median intensity (calculated across all probes containing the corresponding K-mer). In contrast, with *upbm*, K-mer binding affinities are estimated using a mixed effects model, with affinities effectively estimated as the weighted average log-transformed probe intensity across all probes containing the corresponding K-mer. This differs from the cross-probe median intensity in serveral important ways. First, the relative contribution of individual probes to the K-mer summary is inversely related to the variance of the probe across samples, downweighting highly variable probes. Second, to estimate probe-level variability, replicate samples are necessary. Third, because the variance structure is explicitly modeled, statistical testing and inference is possible at the level of K-mers.

In addition to the summarization of DNA binding affinities at the level of individual K-mers, the *upbm* package also allows for testing for differential affinity between groups, e.g. to contrast binding affinity across allelic variants of the same transcription factor. Additionally, the package also allows for identifying preferentially bound K-mers for each groups of replicate samples. The *Universal PBM Analysis Suite* provides the ability to construct mononucleotide position weight matrices (PWMs), again, for individual PBM samples. Approaches for testing differential affinity between samples using the output of the *Universal PBM Analysis Suite* have also been previously described [@barrera2016].

Many of the PBM pre-processing steps of the *Universal PBM Analysis Suite* are maintained in the *upbm* package. These steps have been re-implemented, with some modifications, e.g. in the process of Cy3 normalization, to enable and streamline the complete analysis of PBM data in *R*.

# Installation

To install the latest version of *upbm* along with two dependencies, *upbmAux* and *upbmData*, use the following command from the [`BiocManager`](https://CRAN.R-project.org/package=BiocManager) package:

```{r, eval = FALSE}
BiocManager::install("pkimes/upbm")
BiocManager::install("pkimes/upbmAux")
BiocManager::install("pkimes/upbmData")
```

If the package is already installed, there is no need to re-install the package except to check for updates.
After installing, the package still needs to be loaded to make the functions available in *R*.

```{r}
suppressPackageStartupMessages(library("upbm"))
```

# HOXC9 Data Set

Data from a triplicate series of PBM experiments are used to illustrate the features of the *upbm* package in this vignette. The data set include GenePix Results (GPR) data from Alexa488 scans for wild type human transcription factor (TF) HOXC9 and three allelic variants of the TF (K195R, R193K, R222W). Corresponding Cy3 scans are also included for all arrays. Each array was scanned for Alexa488 fluorescence at multiple PMT gains and Cy3 at a single PMT gain. The series comes from a larger set of experiments studying the effect of allelic variants on human transcription factor binding (manuscript in preparation). Data objects are stored in a separate *upbmData* package for convenience and include a table of sample metadata (`hoxc9table`), a *SummarizedExperiment* of Alexa488 scan data (`hoxc9alexa`), and a *SummarizedExperiment* of Cy3 scan data (`hoxc9cy3`).

```{r}
data(hoxc9table, package = "upbmData")
data(hoxc9alexa, package = "upbmData")
data(hoxc9cy3, package = "upbmData")
```

Metadata for Alexa488 and Cy3 scans are provided in the sample table.

```{r}
hoxc9table
```

Several important metadata variables are recorded in the table - notably, `scan` (scan type), `gpr` (path to the scan GPR file), `lp` (PMT gain of the scan), and `condition` (HOXC9 allele on the scanned array).

# Quickstart

Input data must be available as GenePix Results (GPR) files, with each GPR file corresponding to a single scan of a sample. The GPR files should be organized as a table of scans with each row detailing any important metadata about the scan, e.g. date and scan parameters, and sample, e.g. the name of the transcription factor. The path to the GPR file should be provided in a `gpr` column of the table.

For this vignette, we will use example data included in the *upbmData* package. Details on the experiment are provided in the more complete walkthrough provided below. The GPR scans for this example data set are provided as `hoxc9table`.


Notice that several metadata variables are recorded in addition to the necessary `gpr` column. Most notably,

```{r, eval = FALSE}
pbmtab <- buildPBMTable(gpr_dir)
pbmdat <- buildPBMExperiment(samples, probes = pbm_8x60k_v1)
```

For this vignette, we just use a toy data set included with this package.

```{r}
data(pbmtab)
data(pbmdat)
```

The data is now available for plotting and analysis. Here, we show an example of computing the spatial bias in a subset of samples, and plotting the bias across the grid of probe coordinates.

```{r}
pbm_adjusted <- spatiallyAdjust(pbmdat[, 1:3])
```

```{r, fig.width = 12, fig.height = 4}
pbmPlotChip(pbm_adjusted, assay_name = "spatialbias", log_scale = FALSE)
```

More details on the available plotting and analysis functions are provided in the sections below.

# Overview

## Reading GPR Data

We start by identifying the set of sample GPRs in the directory, `gpr_dir` using the `buildPBMTable` function.

```{r, eval = FALSE}
pbmtab <- buildPBMTable(gpr_dir)
```

Going back to the example data set, the table includes various sample meta data pulled from the file names according to an assumed convention described in the `buildPBMTable` function details.

```{r}
pbmtab
```

By default, only raw `"Alexa"` GPR scans are captured. However, there may also be Cy3 and Masliner GPR files of interest in the same directory. To capture these samples as well, we can change the `gpr_type=` parameter to any of `"Masliner"`, `"Cy3"`, or `"all"`.

```{r, eval = FALSE}
samples_all <- buildPBMTable(gpr_dir, gpr_type = "all")
```

Given the table of samples, we next load the GPR data into R using the `buildPBMExperiment` function. The function reads in GPR data for the files listed in the `gpr` column of the sample table. The `gpr` column is the only required column for input into the `buildPBMExperiment` function. While optional, if possible, the probe design should also be specified when loading the GPR data for easier downstream analysis. For convenience, the default "8x60k" probe design is included in this package as `pbm_8x60_v1`. (The `probes =` argument is described in further detail below.)

```{r, eval = FALSE}
pbmdata <- buildPBMExperiment(samples_all, probes = pbm_8x60k_v1)
```

The sample data is stored as a [_SummarizedExperiment_](https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html), a common structure for storing genomic data in [Bioconductor](http://bioconductor.org/).

```{r}
pbmdata
```

A _SummarizedExperiment_ is made up of three parts: **1.** assays (primary data), **2.** column data, and **3.** row data.  

Naturally, the probe-level intensities from the GPRs are available in the `"fore"` (foreground) **assay** as a DataFrame with rows and columns corresponding to probes and samples. A second assay, `"back"` (background) is also read in from the GPRs with the background intensities for each probe and sample.

```{r}
assay(pbmdata, "fore")[1:5, 1:5]
assay(pbmdata, "back")[1:5, 1:5]
```

The **column data** contains information about the columns (samples).

```{r}
colData(pbmdat)[1:5, ]
```

Similarly, the **row data** contains information about the rows (probes). Recall that when we loaded the GPR data, we also specified the probe design used in this experiment, `pbm_8x60k_v1`. This data is now stored as the row data. 

```{r}
rowData(pbmdat)[1:5, ]
```

The probe information in `pbm_8x60_v1` was matched with the GPR data according to `Row` and `Column` coordinates.

```{r}
head(pbm_8x60k_v1)
```

## Plotting GPR Data

Now that we have the data, we can use plots to visually explore the distributions of probe intensities across samples. Currently, the following functions are available for plotting GPR data: `pbmPlotDensity()`, `pbmPlotChip()`, `pbmPlotScatter()`, and `pbmPlotComparison()`. Each function returns a `ggplot2` object that can be customized to generate more specialized plots. By default, each function plots each sample separately ("facets") according to the `condition` column of the `colData`.

```{r}
colData(pbmdat)$condition
```

If `condition` is not unique to each sample, as is the case here, we can set `.facet = FALSE` in the function, and explicitly facet the returned plot. Faceting can be performed using any of the columns in the `colData` of the SummarizedExperiment.

```{r}
colData(pbmdat)
```

In this example, laser power (`lp`) and `condition` uniquely identify each sample, and can be used for faceting the samples.  

First, we use `lp` and `condition` to facet a plot of the distribution of probe intensities for each sample. 

```{r, fig.width = 10, fig.height = 6}
pbmPlotDensity(pbmdat, .facet = FALSE) +
    facet_grid(lp ~ condition)
```

Similarly, we can plot probe intensities for each sample across the coordinates of the array. 

```{r, fig.width = 10, fig.height = 6}
pbmPlotDensity(pbmdat, .facet = FALSE) +
    facet_grid(lp ~ condition)
```

Since these experiments typically include a reference sample, another useful view of the data is to plot probe intensities across conditions against a reference sample. This may be useful to, for example, compare across conditions for a fixed laser power (`lp`) or across laser powers for a single condition (`condition`). Since the ultimate goal is to compare across samples, we plot the former. To do this, we simply subset the samples (columns) according to the `colData`, and call the plotting function. 

```{r, fig.width = 10, fig.height = 6}
pbmPlotScatter(pbmdat[, colData(pbmdat)$lp == 400])
```

A similar but alternative view of the data is the [MA plot](https://en.wikipedia.org/wiki/MA_plot), which plots the mean log-intensity against the difference in log-intensity for each pair of samples.

```{r, fig.width = 15, fig.height = 5}
pbmPlotScatter(pbmdat[, colData(pbmdat)$lp == 400], maplot = TRUE)
```

Finally, often, we may be interested in comparing across replicates of the same experiment. Here, we illustrate the functionality by comparing conditions across two laser powers. Each sample is matched using a column in the `colData` specified by `match_by = `. Note that the input to `match_by = ` should *not* be quoted.

```{r, fig.width = 15, fig.height = 5}
pbmPlotComparison(pbmdat[, colData(pbmdat)$lp == 400],
                  pbmdat[, colData(pbmdat)$lp == 475],
                  match_by = condition)
```

As above, MA plots are also implemented.

```{r, fig.width = 15, fig.height = 5}
pbmPlotComparison(pbmdat[, colData(pbmdat)$lp == 400],
                  pbmdat[, colData(pbmdat)$lp == 475],
                  match_by = condition,
                  maplot = TRUE)
```

In each of the plots generated above, values are taken from the `"fore"` assay by default. However, background intensities (or any other _assay_) in the _SummarizedExperiment_ can also be plotted by specifying the `assay_name = ` parameter.

```{r, fig.width = 15, fig.height = 5}
pbmPlotDensity(pbmdat, assay_name = "back",
               log_scale = TRUE, .facet = FALSE) +
    facet_grid(lp ~ condition) +
    ggtitle("PBM Background Intensity (log2)")
```

## Pre-Processing GPR Data

**Choice of pre-processing steps for PBM data is still under investigation.**

Approaches for pre-processing of microarray intensities has been widely studied over the past 15 years. Several popular and successful approaches, including RMA, have been implemented and made available through the *affy* and *limma* packages. However, the functions implemented within these packages expect slightly different inputs and generate slighlty different outputs, making it difficult to directly apply the methods to our data stored in *SummarizedExperiment* class. To make access to these functions easier, we have written several wrapper functions to pre-processing functions implemented in both packages.

Single-channal pre-processing includes two primary steps: **within-sample background correction** and **between-sample normalization**. The corresponding functions implemented in *limma* are wrapped as `limmaBackgroundCorrect` and `limmaNormalizeBetweenSamples`. Each function returns the same *SummarizedExperiment* object, but with normalized expression estimates.

The simplest background correction approach is to simply subtract the background intensities from the foreground intensities. This can be done by specifying the background assay name to `assayb_name = "back"` (and optionally `method = "subtract"`). **Currently, we recommend using the "subtract" approach when background intensities are available.**

```{r}
pbmdat_bc <- limmaBackgroundCorrect(pbmdat, assayb_name = "back")
```

If the assay name for the background intensities is not specified, background noise will be estimated using a Normal-Exponential convolution model. (See `help(backgroundCorrect, package = limma)` for more details.)

```{r, eval = FALSE}
## NOT RUN - would use 'normexp' background correction approach
pbmdat_bc <- limmaBackgroundCorrect(pbmdat)
```

Since the returned object is again a SummarizedExperiment, we can easily plot the data using the functions described above. Here, we compare the background corrected and original data for scans at laser power 500.

```{r, fig.width = 15, fig.height = 5}
pbmPlotComparison(pbmdat[, colData(pbmdat)$lp == 400],
                  pbmdat_bc[, colData(pbmdat_bc)$lp == 400])
```

For provenance, the correction step (`limma::backgroundCorrect`) is also noted in the `metadata` of the object along with the name of the modified assay (`fore`). 

```{r}
metadata(pbmdat_bc)
```

We next apply cross-sample normalization. Since a primary objective of normalizing across samples is to put intensities on the same scale, we apply the procedure to only a subset of samples scanned at the same laser intensity. The default is currently to use quantile normalization. **However, based on the observation that samples may have fundamentally different distributional shapes, it is not yet clear if quantile normalization is the best approach for PBM data.** (Again, see `help(normalizeBetweenArrays, package = limma)` for more details.)

```{r}
pbmdat400_norm <- limmaNormalizeBetweenArrays(pbmdat_bc[, colData(pbmdata)$lp == 400])
```

Again, we compare the normalized data against the original data.

```{r, fig.width = 15, fig.height = 5}
pbmPlotComparison(pbmdat_bc[, colData(pbmdat)$lp == 400],
                  pbmdat400_norm, maplot = TRUE)
```

## Filtering GPR Data

**Probe-level filtering procedures are still under investigation.**

## Quantifying GPR Data

After applying pre-processing and filtering to probe-level intensities for each GPR file, we proceed to estimating candidate motif-level affinities. 






# Alternative Inputs

While PBM data are commonly stored as GPR scan files, several similar probe-level summaries files have been generated and made publicly available on platforms include [Uniprobe](http://the_brain.bwh.harvard.edu/uniprobe/) [@hume2014]. In addition to raw GPR data, the *upbm* software can be used to read in alternative sources of extrapolated or processed probe-level intensity data, e.g. from [Masliner](http://arep.med.harvard.edu/masliner/supplement.htm) or the *Universal PBM Analysis Suite*. We recommend using original GPR data files when possible.

# References

